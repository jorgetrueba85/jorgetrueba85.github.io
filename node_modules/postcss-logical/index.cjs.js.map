{"version":3,"file":"index.cjs.js","sources":["lib/clone-rule.js","lib/transform-border.js","lib/transform-float.js","lib/transform-inset.js","lib/transform-resize.js","lib/match-side.js","lib/match-inset-prefix.js","lib/clone-decl.js","lib/transform-side.js","lib/match-size.js","lib/transform-size.js","lib/transform-spacing.js","lib/transform-text-align.js","lib/split.js","lib/transform-transition.js","lib/match-supported-properties.js","index.js"],"sourcesContent":["import postcss from 'postcss';\n\nexport default (decl, dir) => {\n\tconst rule = Object(decl.parent).type === 'rule' ? decl.parent.clone({\n\t\traws: {}\n\t}).removeAll() : postcss.rule({ selector: '&' });\n\n\trule.selectors = rule.selectors.map(selector => `${selector}:dir(${dir})`);\n\n\treturn rule;\n};\n","import cloneRule from './clone-rule';\n\nconst matchLogical = /^\\s*logical\\s+/i;\nconst matchLogicalBorder = /^border(-width|-style|-color)?$/i;\nconst matchLogicalBorderSide = /^border-(block|block-start|block-end|inline|inline-start|inline-end|start|end)(-(width|style|color))?$/i;\n\nexport default {\n\t// border\n\t'border': (decl, values, dir) => {\n\t\tconst isLogical = matchLogical.test(values[0]);\n\n\t\tif (isLogical) {\n\t\t\tvalues[0] = values[0].replace(matchLogical, '');\n\t\t}\n\n\t\tconst ltrDecls = [\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-top${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\tvalue: values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\tvalue: values[1] || values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-bottom${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\tvalue: values[2] || values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\tvalue: values[3] || values[1] || values[0]\n\t\t\t})\n\t\t];\n\n\t\tconst rtlDecls = [\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-top${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\tvalue: values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\tvalue: values[1] || values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-bottom${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\tvalue: values[2] || values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\tvalue: values[3] || values[1] || values[0]\n\t\t\t})\n\t\t];\n\n\t\treturn isLogical ? 1 === values.length\n\t\t\t? decl.clone({\n\t\t\t\tvalue: decl.value.replace(matchLogical, '')\n\t\t\t})\n\t\t\t: !values[3] || values[3] === values[1]\n\t\t\t\t? [\n\t\t\t\t\tdecl.clone({\n\t\t\t\t\t\tprop: `border-top${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\t\t\tvalue: values[0]\n\t\t\t\t\t}),\n\t\t\t\t\tdecl.clone({\n\t\t\t\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\t\t\tvalue: values[3] || values[1] || values[0]\n\t\t\t\t\t}),\n\t\t\t\t\tdecl.clone({\n\t\t\t\t\t\tprop: `border-bottom${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\t\t\tvalue: values[2] || values[0]\n\t\t\t\t\t}),\n\t\t\t\t\tdecl.clone({\n\t\t\t\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorder, '$1')}`,\n\t\t\t\t\t\tvalue: values[1] || values[0]\n\t\t\t\t\t})\n\t\t\t\t]\n\t\t\t\t: 'ltr' === dir ? ltrDecls : 'rtl' === dir ? rtlDecls : [\n\t\t\t\t\tcloneRule(decl, 'ltr').append(ltrDecls),\n\t\t\t\t\tcloneRule(decl, 'rtl').append(rtlDecls)\n\t\t\t\t]\n\t\t\t: null;\n\t},\n\n\t// border-block\n\t'border-block': (decl, values) => [\n\t\tdecl.clone({\n\t\t\tprop: `border-top${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\tvalue: values[0]\n\t\t}),\n\t\tdecl.clone({\n\t\t\tprop: `border-bottom${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\tvalue: values[0]\n\t\t})\n\t],\n\n\t// border-block-start\n\t'border-block-start': decl => {\n\t\tdecl.prop = 'border-top';\n\t},\n\n\t// border-block-end\n\t'border-block-end': decl => {\n\t\tdecl.prop = 'border-bottom';\n\t},\n\n\t// border-inline\n\t'border-inline': (decl, values, dir) => {\n\t\tconst ltrDecls = [\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[1] || values[0]\n\t\t\t})\n\t\t];\n\n\t\tconst rtlDecls = [\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[1] || values[0]\n\t\t\t})\n\t\t];\n\n\t\tconst isLTR = 1 === values.length || 2 === values.length && values[0] === values[1];\n\n\t\treturn isLTR ? ltrDecls : 'ltr' === dir ? ltrDecls : 'rtl' === dir ? rtlDecls : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecls),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecls)\n\t\t];\n\t},\n\n\t// border-inline-start\n\t'border-inline-start': (decl, values, dir) => {\n\t\tconst ltrDecl = decl.clone({\n\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`\n\t\t});\n\n\t\tconst rtlDecl = decl.clone({\n\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`\n\t\t});\n\n\t\treturn 'ltr' === dir ? ltrDecl : 'rtl' === dir ? rtlDecl : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecl),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecl)\n\t\t];\n\t},\n\n\t// border-inline-end\n\t'border-inline-end': (decl, values, dir) => {\n\t\tconst ltrDecl = decl.clone({\n\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`\n\t\t});\n\n\t\tconst rtlDecl = decl.clone({\n\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`\n\t\t});\n\n\t\treturn 'ltr' === dir ? ltrDecl : 'rtl' === dir ? rtlDecl : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecl),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecl)\n\t\t];\n\t},\n\n\t// border-start\n\t'border-start': (decl, values, dir) => {\n\t\tconst ltrDecls = [\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-top${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[1] || values[0]\n\t\t\t})\n\t\t];\n\n\t\tconst rtlDecls = [\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-top${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[1] || values[0]\n\t\t\t})\n\t\t];\n\n\t\treturn 'ltr' === dir ? ltrDecls : 'rtl' === dir ? rtlDecls : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecls),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecls)\n\t\t];\n\t},\n\n\t// border-end\n\t'border-end': (decl, values, dir) => {\n\t\tconst ltrDecls = [\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-bottom${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[1] || values[0]\n\t\t\t})\n\t\t];\n\n\t\tconst rtlDecls = [\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-bottom${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[0]\n\t\t\t}),\n\t\t\tdecl.clone({\n\t\t\t\tprop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`,\n\t\t\t\tvalue: values[1] || values[0]\n\t\t\t})\n\t\t];\n\n\t\treturn 'ltr' === dir ? ltrDecls : 'rtl' === dir ? rtlDecls : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecls),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecls)\n\t\t];\n\t}\n};\n","import cloneRule from './clone-rule';\n\nexport default (decl, values, dir) => {\n\tconst lDecl = decl.clone({ value: 'left' });\n\tconst rDecl = decl.clone({ value: 'right' });\n\n\treturn /^inline-start$/i.test(decl.value) ? 'ltr' === dir ? lDecl : 'rtl' === dir ? rDecl : [\n\t\tcloneRule(decl, 'ltr').append(lDecl),\n\t\tcloneRule(decl, 'rtl').append(rDecl)\n\t] : /^inline-end$/i.test(decl.value) ? 'ltr' === dir ? rDecl : 'rtl' === dir ? lDecl : [\n\t\tcloneRule(decl, 'ltr').append(rDecl),\n\t\tcloneRule(decl, 'rtl').append(lDecl)\n\t] : null;\n};\n","import cloneRule from './clone-rule';\n\nexport default (decl, values, dir) => {\n\tif ('logical' !== values[0]) {\n\t\treturn [\n\t\t\tdecl.clone({ prop: 'top', value: values[0] }),\n\t\t\tdecl.clone({ prop: 'right', value: values[1] || values[0] }),\n\t\t\tdecl.clone({ prop: 'bottom', value: values[2] || values[0] }),\n\t\t\tdecl.clone({ prop: 'left', value: values[3] || values[1] || values[0] })\n\t\t];\n\t}\n\n\tconst isLTR = !values[4] || values[4] === values[2];\n\n\tconst ltrDecls = [\n\t\tdecl.clone({ prop: 'top', value: values[1] }),\n\t\tdecl.clone({ prop: 'left', value: values[2] || values[1] }),\n\t\tdecl.clone({ prop: 'bottom', value: values[3] || values[1] }),\n\t\tdecl.clone({ prop: 'right', value: values[4] || values[2] || values[1] })\n\t];\n\n\tconst rtlDecls = [\n\t\tdecl.clone({ prop: 'top', value: values[1] }),\n\t\tdecl.clone({ prop: 'right', value: values[2] || values[1] }),\n\t\tdecl.clone({ prop: 'bottom', value: values[3] || values[1] }),\n\t\tdecl.clone({ prop: 'left', value: values[4] || values[2] || values[1] })\n\t];\n\n\treturn isLTR || 'ltr' === dir ? ltrDecls : 'rtl' === dir ? rtlDecls : [\n\t\tcloneRule(decl, 'ltr').append(ltrDecls),\n\t\tcloneRule(decl, 'rtl').append(rtlDecls)\n\t];\n}\n","export default decl => /^block$/i.test(decl.value)\n\t? decl.clone({ value: 'vertical' })\n\t: /^inline$/i.test(decl.value)\n\t\t? decl.clone({ value: 'horizontal' })\n\t\t: null;\n","export default /^(inset|margin|padding)(?:-(block|block-start|block-end|inline|inline-start|inline-end|start|end))$/i;\n","export default /^inset-/i;\n","import matchSide from './match-side';\nimport matchInsetPrefix from './match-inset-prefix';\n\nexport default (decl, suffix, value) => decl.clone({\n\tprop: `${decl.prop.replace(matchSide, '$1')}${suffix}`.replace(matchInsetPrefix, ''),\n\tvalue\n});\n","import cloneDecl from './clone-decl';\nimport cloneRule from './clone-rule';\nimport matchSide from './match-side';\n\nimport matchInsetPrefix from './match-inset-prefix';\n\nexport default {\n\t// inset-block, margin-block, padding-block\n\t'block': (decl, values) => [\n\t\tcloneDecl(decl, '-top', values[0]),\n\t\tcloneDecl(decl, '-bottom', values[1] || values[0])\n\t],\n\n\t// inset-block-start, margin-block-start, padding-block-start\n\t'block-start': decl => {\n\t\tdecl.prop = decl.prop.replace(matchSide, '$1-top').replace(matchInsetPrefix, '');\n\t},\n\n\t// inset-block-end, margin-block-end, padding-block-end\n\t'block-end': decl => {\n\t\tdecl.prop = decl.prop.replace(matchSide, '$1-bottom').replace(matchInsetPrefix, '');\n\t},\n\n\t// inset-inline, margin-inline, padding-inline\n\t'inline': (decl, values, dir) => {\n\t\tconst ltrDecls = [\n\t\t\tcloneDecl(decl, '-left', values[0]),\n\t\t\tcloneDecl(decl, '-right', values[1] || values[0])\n\t\t];\n\n\t\tconst rtlDecls = [\n\t\t\tcloneDecl(decl, '-right', values[0]),\n\t\t\tcloneDecl(decl, '-left', values[1] || values[0])\n\t\t];\n\n\t\tconst isLTR = 1 === values.length || 2 === values.length && values[0] === values[1];\n\n\t\treturn isLTR ? ltrDecls : 'ltr' === dir ? ltrDecls : 'rtl' === dir ? rtlDecls : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecls),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecls),\n\t\t];\n\t},\n\n\t// inset-inline-start, margin-inline-start, padding-inline-start\n\t'inline-start': (decl, values, dir) => {\n\t\tconst ltrDecl = cloneDecl(decl, '-left', decl.value);\n\t\tconst rtlDecl = cloneDecl(decl, '-right', decl.value);\n\n\t\treturn 'ltr' === dir ? ltrDecl : 'rtl' === dir ? rtlDecl : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecl),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecl)\n\t\t];\n\t},\n\n\t// inset-inline-end, margin-inline-end, padding-inline-end\n\t'inline-end': (decl, values, dir) => {\n\t\tconst ltrDecl = cloneDecl(decl, '-right', decl.value);\n\t\tconst rtlDecl = cloneDecl(decl, '-left', decl.value);\n\n\t\treturn 'ltr' === dir ? ltrDecl : 'rtl' === dir ? rtlDecl : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecl),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecl)\n\t\t];\n\t},\n\n\t// inset-start, margin-start, padding-start\n\t'start': (decl, values, dir) => {\n\t\tconst ltrDecls = [\n\t\t\tcloneDecl(decl, '-top', values[0]),\n\t\t\tcloneDecl(decl, '-left', values[1] || values[0])\n\t\t];\n\n\t\tconst rtlDecls = [\n\t\t\tcloneDecl(decl, '-top', values[0]),\n\t\t\tcloneDecl(decl, '-right', values[1] || values[0])\n\t\t];\n\n\t\treturn 'ltr' === dir ? ltrDecls : 'rtl' === dir ? rtlDecls : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecls),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecls)\n\t\t];\n\t},\n\n\t// inset-end, margin-end, padding-end\n\t'end': (decl, values, dir) => {\n\t\tconst ltrDecls = [\n\t\t\tcloneDecl(decl, '-bottom', values[0]),\n\t\t\tcloneDecl(decl, '-right', values[1] || values[0])\n\t\t];\n\n\t\tconst rtlDecls = [\n\t\t\tcloneDecl(decl, '-bottom', values[0]),\n\t\t\tcloneDecl(decl, '-left', values[1] || values[0])\n\t\t];\n\n\t\treturn 'ltr' === dir ? ltrDecls : 'rtl' === dir ? rtlDecls : [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecls),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecls)\n\t\t];\n\t}\n}\n","export default /^(min-|max-)?(block|inline)-(size)$/i;\n","import matchSize from './match-size';\n\nexport default decl => {\n\tdecl.prop = decl.prop.replace(\n\t\tmatchSize,\n\t\t($0, minmax, flow) => `${minmax||''}${'block' === flow ? 'height' : 'width'}`\n\t);\n};\n","import cloneRule from './clone-rule';\n\nexport default (decl, values, dir) => {\n\tif ('logical' !== values[0]) {\n\t\treturn null;\n\t}\n\n\tconst isLTR = !values[4] || values[4] === values[2];\n\n\tconst ltrDecl = decl.clone({\n\t\tvalue: [\n\t\t\tvalues[1],\n\t\t\tvalues[4] || values[2] || values[1],\n\t\t\tvalues[3] || values[1],\n\t\t\tvalues[2] || values[1]\n\t\t].join(' ')\n\t});\n\n\tconst rtlDecl = decl.clone({\n\t\tvalue: [\n\t\t\tvalues[1],\n\t\t\tvalues[2] || values[1],\n\t\t\tvalues[3] || values[1],\n\t\t\tvalues[4] || values[2] || values[1]\n\t\t].join(' ')\n\t});\n\n\treturn isLTR ? decl.clone({\n\t\tvalue: decl.value.replace(/^\\s*logical\\s+/i, '')\n\t}) : 'ltr' === dir ? ltrDecl : 'rtl' === dir ? rtlDecl : [\n\t\tcloneRule(decl, 'ltr').append(ltrDecl),\n\t\tcloneRule(decl, 'rtl').append(rtlDecl)\n\t];\n};\n","import cloneRule from './clone-rule';\n\nexport default (decl, values, dir) => {\n\tconst lDecl = decl.clone({ value: 'left' });\n\tconst rDecl = decl.clone({ value: 'right' });\n\n\treturn /^start$/i.test(decl.value) ? 'ltr' === dir ? lDecl : 'rtl' === dir ? rDecl : [\n\t\tcloneRule(decl, 'ltr').append(lDecl),\n\t\tcloneRule(decl, 'rtl').append(rDecl)\n\t] : /^end$/i.test(decl.value) ? 'ltr' === dir ? rDecl : 'rtl' === dir ? lDecl : [\n\t\tcloneRule(decl, 'ltr').append(rDecl),\n\t\tcloneRule(decl, 'rtl').append(lDecl)\n\t] : null;\n};\n","export function splitByComma(string, isTrimmed) {\n\treturn splitByRegExp(string, /^,$/, isTrimmed);\n}\n\nexport function splitBySpace(string, isTrimmed) {\n\treturn splitByRegExp(string, /^\\s$/, isTrimmed);\n}\n\nexport function splitBySlash(string, isTrimmed) {\n\treturn splitByRegExp(string, /^\\/$/, isTrimmed);\n}\n\nfunction splitByRegExp(string, re, isTrimmed) {\n\tconst array = [];\n\tlet buffer = '';\n\tlet split = false;\n\tlet func = 0;\n\tlet i = -1;\n\n\twhile (++i < string.length) {\n\t\tconst char = string[i];\n\n\t\tif (char === '(') {\n\t\t\tfunc += 1;\n\t\t} else if (char === ')') {\n\t\t\tif (func > 0) {\n\t\t\t\tfunc -= 1;\n\t\t\t}\n\t\t} else if (func === 0) {\n\t\t\tif (re.test(char)) {\n\t\t\t\tsplit = true;\n\t\t\t}\n\t\t}\n\n\t\tif (split) {\n\t\t\tif (!isTrimmed || buffer.trim()) {\n\t\t\t\tarray.push(isTrimmed ? buffer.trim() : buffer);\n\t\t\t}\n\n\t\t\tif (!isTrimmed) {\n\t\t\t\tarray.push(char);\n\t\t\t}\n\n\t\t\tbuffer = '';\n\t\t\tsplit = false;\n\t\t} else {\n\t\t\tbuffer += char\n\t\t}\n\t}\n\n\tif (buffer !== '') {\n\t\tarray.push(isTrimmed ? buffer.trim() : buffer);\n\t}\n\n\treturn array;\n}\n","import cloneRule from './clone-rule';\nimport { splitByComma, splitBySpace } from './split';\n\nexport default (decl, notValues, dir) => {\n\tconst ltrValues = [];\n\tconst rtlValues = [];\n\n\tsplitByComma(decl.value).forEach(value => {\n\t\tlet hasBeenSplit = false;\n\n\t\tsplitBySpace(value).forEach((word, index, words) => {\n\t\t\tif (word in valueMap) {\n\t\t\t\thasBeenSplit = true;\n\n\t\t\t\tvalueMap[word].ltr.forEach(replacement => {\n\t\t\t\t\tconst clone = words.slice();\n\n\t\t\t\t\tclone.splice(index, 1, replacement);\n\n\t\t\t\t\tif (ltrValues.length && !/^,$/.test(ltrValues[ltrValues.length - 1])) {\n\t\t\t\t\t\tltrValues.push(',');\n\t\t\t\t\t}\n\n\t\t\t\t\tltrValues.push(clone.join(''));\n\t\t\t\t});\n\n\t\t\t\tvalueMap[word].rtl.forEach(replacement => {\n\t\t\t\t\tconst clone = words.slice();\n\n\t\t\t\t\tclone.splice(index, 1, replacement);\n\n\t\t\t\t\tif (rtlValues.length && !/^,$/.test(rtlValues[rtlValues.length - 1])) {\n\t\t\t\t\t\trtlValues.push(',');\n\t\t\t\t\t}\n\n\t\t\t\t\trtlValues.push(clone.join(''));\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tif (!hasBeenSplit) {\n\t\t\tltrValues.push(value);\n\t\t\trtlValues.push(value);\n\t\t}\n\t});\n\n\tconst ltrDecl = decl.clone({ value: ltrValues.join('') });\n\tconst rtlDecl = decl.clone({ value: rtlValues.join('') });\n\n\treturn ltrValues.length && 'ltr' === dir\n\t\t? ltrDecl\n\t: rtlValues.length && 'rtl' === dir\n\t\t? rtlDecl\n\t: ltrDecl.value !== rtlDecl.value\n\t\t? [\n\t\t\tcloneRule(decl, 'ltr').append(ltrDecl),\n\t\t\tcloneRule(decl, 'rtl').append(rtlDecl)\n\t\t]\n\t: null;\n};\n\nconst va